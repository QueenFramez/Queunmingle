<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VideoConnect â€” Random Video Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">

  <style>
    /* Reset & base */
    :root {
      --bg-1: #070707;
      --bg-2: #1e1e1e;
      --accent: #ffd700;
      --muted: #9a9a9a;
      --panel: rgba(255, 255, 255, 0.05);
      --glass: rgba(255, 255, 255, 0.05);
      --positive: #34d399; /* Tailwind emerald-400 */
      --danger: #ef4444; /* Tailwind red-500 */
      --radius: 12px;
      --shadow-1: 0 6px 24px rgba(0, 0, 0, 0.6);
      --glass-border: rgba(255, 215, 0, 0.1);
      --max-width: 1200px;
    }

    body {
      font-family: 'Inter', sans-serif;
      background-color: var(--bg-1);
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 1rem;
    }

    .container {
      max-width: var(--max-width);
      width: 100%;
      background-color: var(--bg-2);
      border-radius: var(--radius);
      box-shadow: var(--shadow-1);
      padding: 1rem;
      transition: all 0.3s ease;
    }

    /* Video Panel Styling - Adjusted for 1:1 Aspect Ratio */
    .video-panel {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
      width: 100%;
      margin-bottom: 1.5rem;
      position: relative;
    }

    /* Small media queries for side-by-side video on wider screens */
    @media (min-width: 768px) {
      .video-panel {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    .video-container {
      position: relative;
      background-color: #000;
      border-radius: var(--radius);
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      border: 1px solid var(--panel);
      /* 1:1 Aspect Ratio implementation */
      width: 100%;
      padding-bottom: 100%; /* Height equals width */
    }

    /* Position the video and placeholder absolutely within the 1:1 container */
    video, .video-placeholder {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* Mirror local video */
    }

    .video-placeholder {
      position: absolute;
      transform: none; /* Do not mirror the placeholder text */
      background: rgba(0, 0, 0, 0.7);
      color: var(--muted);
      font-weight: 500;
      z-index: 10;
      opacity: 1;
      transition: opacity 0.5s ease;
      display: flex; /* Re-apply flex to center content */
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }


    .hidden-placeholder {
      opacity: 0;
      pointer-events: none;
    }

    /* Controls Styling */
    .control-panel {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
      padding: 1rem 0;
    }

    .status-badge {
      padding: 0.5rem 1rem;
      border-radius: 9999px;
      font-weight: 600;
      font-size: 0.875rem;
      transition: background-color 0.3s;
    }

    .status-badge.idle, .status-badge.disconnected {
      background-color: var(--danger);
      color: white;
    }
    .status-badge.searching {
      background-color: var(--accent);
      color: #121212;
      animation: pulse 1.5s infinite;
    }
    .status-badge.matched {
      background-color: var(--positive);
      color: #121212;
    }
    .status-badge.not_found {
        background-color: var(--danger);
        color: white;
        animation: none;
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border-radius: var(--radius);
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      font-size: 1rem;
    }

    .btn-primary {
      background-color: var(--accent);
      color: var(--bg-1);
    }

    .btn-primary:hover:not(:disabled) {
      background-color: #f7e69f;
    }

    .btn-danger {
      background-color: var(--danger);
      color: white;
    }

    .btn-danger:hover:not(:disabled) {
      background-color: #f87171;
    }
    
    /* New style for the "Back" button */
    .btn-secondary {
      background-color: var(--panel); /* Darker panel color */
      color: white;
      border: 1px solid var(--glass-border);
    }
    .btn-secondary:hover:not(:disabled) {
      background-color: rgba(255, 255, 255, 0.1);
    }
    
    /* Disabled state for all buttons */
    .btn:disabled, .btn[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }


    .icon-controls {
      display: flex;
      gap: 0.75rem;
      flex-grow: 1;
      justify-content: center;
    }

    .icon-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background-color: var(--panel);
      color: white;
      border: 1px solid var(--glass-border);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.25rem;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
    }

    .icon-btn:hover:not(:disabled) {
      background-color: rgba(255, 255, 255, 0.1);
    }
    
    .icon-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
    }


    .icon-btn.active {
      background-color: var(--positive);
      color: var(--bg-1);
    }

    .icon-btn.disabled {
      background-color: var(--danger);
      color: white;
    }

    /* Modal Styling */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(5px);
    }

    .modal-content {
      background-color: var(--bg-2);
      margin: 15% auto;
      padding: 2rem;
      border: 1px solid var(--glass-border);
      width: 90%;
      max-width: 500px;
      border-radius: var(--radius);
      box-shadow: var(--shadow-1);
      position: relative;
    }

    .modal-close {
      color: var(--muted);
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .modal-close:hover,
    .modal-close:focus {
      color: var(--accent);
      text-decoration: none;
    }

    .premium-tag {
      background-color: var(--accent);
      color: var(--bg-1);
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-weight: 700;
      font-size: 0.75rem;
      margin-left: 0.5rem;
    }
    
    /* Styles for plan cards and filter buttons */
    .plan-card {
      transition: all 0.2s ease;
      background-color: rgba(30, 30, 30, 0.9);
    }
    .plan-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(255, 215, 0, 0.2);
    }
    
    .select-plan-btn {
      min-width: 100px;
    }
    
    .filter-btn {
      width: auto;
      min-width: 80px;
      height: 40px;
      border-radius: var(--radius);
      background-color: var(--panel);
      font-size: 0.9rem;
      font-weight: 500;
      gap: 0.5rem;
      border: 1px solid var(--glass-border);
    }

    .filter-btn.active {
      background-color: var(--accent);
      color: var(--bg-1);
    }
    
    /* Loader for searching status */
    .spinner {
        border: 3px solid rgba(0, 0, 0, 0.1);
        border-top: 3px solid #121212;
        border-radius: 50%;
        width: 16px;
        height: 16px;
        animation: spin 1s linear infinite;
        margin-right: 0.5rem;
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }


    /* Small screen adjustment for controls */
    @media (max-width: 640px) {
      .control-panel {
        flex-direction: column;
      }
      .icon-controls {
        order: 3;
        width: 100%;
        margin-top: 1rem;
      }
      .status-group {
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .main-action-group {
        width: 100%;
        display: flex; /* Ensure action group uses flex for buttons */
      }
      .btn {
        width: 100%;
        flex-grow: 1;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <header class="flex justify-between items-center mb-4">
      <h1 class="text-2xl font-bold flex items-center">VideoConnect <span id="premiumIndicator"></span></h1>
      <div id="userIdDisplay" class="text-xs text-right p-2 rounded-lg bg-gray-800 text-muted">
        User ID: Loading...
      </div>
    </header>

    <!-- Video Display Area -->
    <div class="video-panel">
      <!-- Local Video -->
      <div class="video-container">
        <video id="localVideo" autoplay muted playsinline></video>
        <div id="localPlaceholder" class="video-placeholder">
          <i class="fas fa-video text-3xl mb-2"></i>
          <span>Your Camera</span>
        </div>
      </div>

      <!-- Remote Video -->
      <div class="video-container">
        <video id="remoteVideo" autoplay playsinline></video>
        <div id="remotePlaceholder" class="video-placeholder">
          <i class="fas fa-user-friends text-3xl mb-2"></i>
          <span id="remoteStatusText">Awaiting Match...</span>
        </div>
      </div>
    </div>

    <!-- Controls -->
    <div class="control-panel">
      <div class="status-group flex items-center gap-4">
        <span id="connectionStatus" class="status-badge idle">Ready to Connect</span>
        <!-- Gender Filter Button -->
        <button id="premiumBtn" class="text-sm text-gray-400 hover:text-accent font-medium transition duration-200 flex items-center gap-1">
          <i class="fas fa-filter"></i> Gender Filter
        </button>
      </div>

      <div class="icon-controls">
        <button id="micToggle" class="icon-btn" aria-label="Toggle Microphone" disabled>
          <i class="fas fa-microphone-slash"></i>
        </button>
        <button id="cameraToggle" class="icon-btn" aria-label="Toggle Camera" disabled>
          <i class="fas fa-video-slash"></i>
        </button>
      </div>

      <!-- Main Action Group - Handles all connection states -->
      <div class="main-action-group flex gap-2 w-full md:w-auto">
        <!-- Visible when Disconnected/Searching -->
        <button id="connectBtn" class="btn btn-primary flex-grow">
          <i class="fas fa-search"></i> Start Matching
        </button>
        
        <!-- These buttons are visible when Connected -->
        <button id="nextPartnerBtn" class="btn btn-primary hidden flex-grow md:flex-grow-0">
          <i class="fas fa-forward"></i> Next Partner
        </button>
        <button id="endCallBtn" class="btn btn-danger hidden flex-grow md:flex-grow-0">
          <i class="fas fa-phone-slash"></i> End Call
        </button>
        <!-- The back button is disabled if no previous partner is available -->
        <button id="backBtn" class="btn btn-secondary hidden flex-grow md:flex-grow-0" disabled>
          <i class="fas fa-chevron-left"></i> Back
        </button>
      </div>
    </div>
  </div>

  <!-- Subscription/Filter Modal -->
  <div id="premiumModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="premiumTitle" aria-hidden="true">
    <div class="modal-content">
      <span id="closePremiumSpan" class="modal-close">&times;</span>
      <h2 id="premiumTitle" class="text-2xl font-bold mb-4 text-accent">Gender Filter Access</h2>
      
      <!-- Plan Options (Visible if premiumActive is false) -->
      <div id="planOptionsContainer">
        <p class="mb-6 text-gray-300">
          Select a plan to activate the **Gender Filter** and choose who you connect with. All plans offer the same premium features.
        </p>
  
        <!-- Plan Cards Container -->
        <div class="space-y-4">
          <!-- 1. Weekly Trial -->
          <div id="planWeekly" data-plan="weekly" class="plan-card p-4 rounded-xl border border-gray-700 hover:border-accent transition cursor-pointer bg-gray-800">
            <div class="flex justify-between items-center">
              <div>
                <p class="text-lg font-bold">Weekly Trial</p>
                <p class="text-sm text-positive font-medium">7 Days Free, then $4.99/week</p>
              </div>
              <button class="select-plan-btn btn btn-primary text-sm p-2" data-plan-id="weekly">Start Trial</button>
            </div>
          </div>
          
          <!-- 2. Monthly Plan -->
          <div id="planMonthly" data-plan="monthly" class="plan-card p-4 rounded-xl border border-gray-700 hover:border-accent transition cursor-pointer bg-gray-800">
            <div class="flex justify-between items-center">
              <div>
                <p class="text-lg font-bold">Monthly Plan</p>
                <p class="text-sm text-gray-400">$14.99/month <span class="text-xs text-accent font-semibold">(Save 25%)</span></p>
              </div>
              <button class="select-plan-btn btn btn-primary text-sm p-2" data-plan-id="monthly">Select</button>
            </div>
          </div>
  
          <!-- 3. 6 Month Plan -->
          <div id="planSixMonth" data-plan="sixmonth" class="plan-card p-4 rounded-xl border border-gray-700 hover:border-accent transition cursor-pointer bg-gray-800">
            <div class="flex justify-between items-center">
              <div>
                <p class="text-lg font-bold">6 Month Plan</p>
                <p class="text-sm text-gray-400">$49.99/6 months <span class="text-xs text-positive font-semibold">(Best Value!)</span></p>
              </div>
              <button class="select-plan-btn btn btn-primary text-sm p-2" data-plan-id="sixmonth">Select</button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Gender Selection Filter (Visible if premiumActive is true) -->
      <div id="genderSelection" class="mt-6 p-4 border border-positive bg-gray-800 rounded-xl" style="display: none;">
        <p class="text-positive font-semibold mb-3 text-lg">Gender Filter Active!</p>
        <p class="text-sm text-gray-400 mb-4">Choose the preferred gender for your next connection:</p>
        <div class="flex gap-4 flex-wrap justify-center">
          <button data-filter="male" class="filter-btn icon-btn flex-col">
            <i class="fas fa-mars"></i> Male
          </button>
          <button data-filter="female" class="filter-btn icon-btn flex-col">
            <i class="fas fa-venus"></i> Female
          </button>
          <button data-filter="any" class="filter-btn icon-btn flex-col">
            <i class="fas fa-users"></i> Any
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Question Modal (Used here as a simple status message) -->
  <div id="questionModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="questionTitle" aria-hidden="true">
    <div class="modal-content">
      <span id="closeQuestionSpan" class="modal-close">&times;</span>
      <h2 id="questionTitle" class="text-2xl font-bold mb-4 text-positive">Welcome!</h2>
      <p class="mb-4 text-gray-300">
        You are successfully connected. Your user ID is visible in the top right. This is a secure, authenticated session. Click "Start Matching" to connect with someone online.
      </p>
      <button id="closeQuestionBtn" class="btn btn-primary w-full">Got It</button>
    </div>
  </div>

  <script type="module">
    // --- Firebase/Firestore Imports and Global Variables ---
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, setPersistence, browserSessionPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { 
        getFirestore, doc, setDoc, onSnapshot, updateDoc, Timestamp,
        collection, query, where, getDocs, deleteDoc, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Global variables (MUST be defined as per environment instructions)
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    let app, db, auth;
    let currentUserId = null;
    const USER_SETTINGS_PATH = (userId) => `artifacts/${appId}/users/${userId}/vc_status/settings`;

    // --- Application State ---
    const appState = {
      isAuthReady: false,
      // Main state for connection: 'idle', 'searching', 'not_found', 'matched'
      connectionStatus: 'idle', 
      cameraOn: false,
      micOn: false,
      premiumActive: false,
      currentPlan: null, 
      genderFilter: 'any', 
      localStream: null,
      remoteStream: null, 
      
      // History for 'Back' button
      lastPartnerId: null, 
      lastPartnerName: null,
      currentPartnerId: null, 
      currentPartnerName: null,
    };
    
    // Simple helper for generating simulated partner data
    const NAMES = ["Alex", "Jordan", "Taylor", "Kai", "Rylie", "Jesse", "Sam", "Drew"];
    function generatePartnerName(id) {
        // Use a consistent name based on ID for simulation stability
        const index = id.charCodeAt(0) % NAMES.length;
        return NAMES[index];
    }
    
    // Firestore Path for real-time presence
    function getOnlineUsersCollectionRef() {
        return collection(db, 'artifacts', appId, 'public', 'data', 'online_users');
    }


    // --- DOM Elements ---
    const elements = {
      connectBtn: document.getElementById('connectBtn'),
      nextPartnerBtn: document.getElementById('nextPartnerBtn'), 
      endCallBtn: document.getElementById('endCallBtn'),        
      backBtn: document.getElementById('backBtn'),               
      micToggle: document.getElementById('micToggle'),
      cameraToggle: document.getElementById('cameraToggle'),
      connectionStatus: document.getElementById('connectionStatus'),
      localVideo: document.getElementById('localVideo'),
      remoteVideo: document.getElementById('remoteVideo'),
      localPlaceholder: document.getElementById('localPlaceholder'),
      remotePlaceholder: document.getElementById('remotePlaceholder'),
      remoteStatusText: document.getElementById('remoteStatusText'),
      userIdDisplay: document.getElementById('userIdDisplay'),
      premiumIndicator: document.getElementById('premiumIndicator'),
      premiumBtn: document.getElementById('premiumBtn'),
      premiumModal: document.getElementById('premiumModal'),
      questionModal: document.getElementById('questionModal'),
      
      // New elements for plan/filter
      planOptionsContainer: document.getElementById('planOptionsContainer'),
      genderSelectionDiv: document.getElementById('genderSelection'),
      selectPlanButtons: document.querySelectorAll('.select-plan-btn'),
      filterButtons: document.querySelectorAll('#genderSelection .filter-btn'), 
      
      closePremiumSpan: document.getElementById('closePremiumSpan'),
      closeQuestionSpan: document.getElementById('closeQuestionSpan'),
      closeQuestionBtn: document.getElementById('closeQuestionBtn'),
    };

    // --- Utility Functions ---

    /** Renders the entire UI based on the current appState. */
    function renderApp() {
      const status = appState.connectionStatus;
      const isConnected = status === 'matched';
      const isSearching = status === 'searching';
      const canGoBack = appState.lastPartnerId !== null;

      // 1. Connection Status and Main Buttons
      
      elements.connectBtn.classList.toggle('hidden', isConnected);
      elements.nextPartnerBtn.classList.toggle('hidden', !isConnected);
      elements.endCallBtn.classList.toggle('hidden', !isConnected);
      elements.backBtn.classList.toggle('hidden', !isConnected);
      
      elements.backBtn.disabled = !canGoBack;

      // 2. Main Button Content
      elements.connectBtn.innerHTML = '<i class="fas fa-search"></i> Start Matching';
      elements.connectBtn.disabled = isSearching || status === 'not_found';
      elements.connectBtn.onclick = connect;
      
      if (isSearching) {
        elements.connectBtn.innerHTML = '<div class="spinner"></div> Searching...';
      } else if (status === 'not_found') {
        elements.connectBtn.innerHTML = '<i class="fas fa-times-circle"></i> No Partner Found';
      }

      // 3. Status Badge
      elements.connectionStatus.className = `status-badge ${status}`;
      
      let statusText = 'Ready to Connect';
      if (status === 'searching') {
        statusText = 'Searching for partner...';
      } else if (status === 'not_found') {
        statusText = 'No Partner Found. Try again.';
      } else if (status === 'matched') {
        statusText = `Matched with ${appState.currentPartnerName}`;
      }
      elements.connectionStatus.textContent = statusText;

      // 4. Icon Toggles (Mic/Camera)
      elements.micToggle.disabled = isSearching || status === 'idle' || status === 'not_found';
      elements.cameraToggle.disabled = isSearching || status === 'idle' || status === 'not_found';
      
      elements.micToggle.className = `icon-btn ${appState.micOn ? 'active' : 'disabled'}`;
      elements.micToggle.innerHTML = `<i class="fas fa-microphone${appState.micOn ? '' : '-slash'}"></i>`;

      elements.cameraToggle.className = `icon-btn ${appState.cameraOn ? 'active' : 'disabled'}`;
      elements.cameraToggle.innerHTML = `<i class="fas fa-video${appState.cameraOn ? '' : '-slash'}"></i>`;

      // 5. Video Display
      const hasVideo = appState.localStream && appState.cameraOn;
      elements.localPlaceholder.classList.toggle('hidden-placeholder', hasVideo);
      elements.remotePlaceholder.classList.toggle('hidden-placeholder', isConnected);
      
      let remoteStatusDisplay = 'Awaiting Match...';
      if (isConnected) {
          remoteStatusDisplay = `Connected to ${appState.currentPartnerName}`;
      } else if (isSearching) {
          remoteStatusDisplay = 'Searching...';
      } else if (status === 'not_found') {
          remoteStatusDisplay = 'No Partner Found.';
      }
      elements.remoteStatusText.textContent = remoteStatusDisplay;

      // 6. Premium Indicator / Filter Status
      if (appState.premiumActive) {
        elements.premiumIndicator.innerHTML = `<span class="premium-tag">FILTER: ${appState.genderFilter.toUpperCase()}</span>`;
      } else {
        elements.premiumIndicator.innerHTML = '';
      }
      
      if (elements.genderSelectionDiv && elements.planOptionsContainer) {
        elements.genderSelectionDiv.style.display = appState.premiumActive ? 'flex' : 'none';
        elements.planOptionsContainer.style.display = appState.premiumActive ? 'none' : 'block';

        elements.filterButtons.forEach(btn => {
            const isActive = btn.dataset.filter === appState.genderFilter;
            btn.classList.toggle('active', isActive);
        });
      }
    }

    /** Toggles the state of a media track (audio or video). */
    function toggleMedia(type, newState) {
      if (!appState.localStream) return;

      const trackType = type === 'audio' ? 'micOn' : 'cameraOn';
      const track = appState.localStream.getTracks().find(t => t.kind === type);

      if (track) {
        track.enabled = newState;
        appState[trackType] = newState;
      } else if (type === 'video' && !newState) {
         appState[trackType] = newState;
      }
      renderApp();
    }

    // --- Media (WebRTC Simulation) Functions ---

    /** Attempts to get the local media stream. */
    async function startLocalStream() {
      if (appState.localStream) {
        return appState.localStream;
      }
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        appState.localStream = stream;
        elements.localVideo.srcObject = stream;
        appState.cameraOn = true;
        appState.micOn = true;
        toggleMedia('audio', true); 
        toggleMedia('video', true); 
        return stream;
      } catch (error) {
        console.error("Failed to get local media stream:", error);
        appState.cameraOn = false;
        appState.micOn = false;
        appState.localStream = null;
        // Do not stop search if stream fails, allow user to try again later
        renderApp();
        return null;
      }
    }

    /** Placeholder function for actual call setup */
    async function startCall(partnerId, partnerName) {
        await startLocalStream();
        appState.connectionStatus = 'matched';
        appState.currentPartnerId = partnerId;
        appState.currentPartnerName = partnerName;
        // Simulate a placeholder remote stream (use local stream for visual feedback)
        elements.remoteVideo.srcObject = elements.localVideo.srcObject; 
        console.log(`Connection established with: ${partnerName} (${partnerId})`);
        renderApp();
    }
    
    /** Stops media and fully disconnects the session. */
    async function endCall(shouldSaveHistory = true) {
      const status = appState.connectionStatus;
      
      // Clean up Firestore and local state
      await goOffline(appState.currentPartnerId); // Go offline and unclaim if matched

      if (shouldSaveHistory && appState.currentPartnerId) {
          // Save the current partner to history (lastPartner)
          appState.lastPartnerId = appState.currentPartnerId;
          appState.lastPartnerName = appState.currentPartnerName;
          console.log(`Saved ${appState.lastPartnerName} to history.`);
      }
      
      // Reset current partner
      appState.currentPartnerId = null;
      appState.currentPartnerName = null;
      appState.connectionStatus = 'idle';
      
      elements.remoteVideo.srcObject = null;

      // 1. Stop local tracks if needed (only if we are truly ending the session, not just switching partners)
      if (status !== 'searching') { 
        if (appState.localStream) {
            appState.localStream.getTracks().forEach(track => track.stop());
        }
        elements.localVideo.srcObject = null;
        appState.localStream = null;
        appState.cameraOn = false;
        appState.micOn = false;
      }

      console.log('Call ended and state reset.');
      renderApp();
    }

    /** Ends the current match and immediately starts searching for a new one. */
    function nextPartner() {
      if (appState.connectionStatus !== 'matched') return;

      console.log('Ending current match and searching for next partner...');
      // Disconnect but save current partner to history
      endCall(true); 
      
      // Immediately start the connection process again.
      connect();
    }
    
    /** Ends the current match and attempts to reconnect to the previous partner. */
    function backToPreviousPartner() {
      if (!appState.lastPartnerId || appState.connectionStatus === 'searching') return;
      
      const prevId = appState.lastPartnerId;
      const prevName = appState.lastPartnerName;

      // Disconnect current (if connected). Do NOT save history.
      endCall(false);

      // Clear history immediately to prevent going back twice in a row
      appState.lastPartnerId = null;
      appState.lastPartnerName = null;
      
      console.log(`Attempting to go back to ${prevName} (${prevId})...`);

      // Attempt immediate reconnection (simulated as found)
      startCall(prevId, prevName); 
    }
    
    // --- Firestore Partner Management ---

    /** Sets the current user's status to 'available' in Firestore. */
    async function goOnline() {
        if (!currentUserId || !db) return;
        try {
            await setDoc(doc(getOnlineUsersCollectionRef(), currentUserId), {
                status: 'available',
                filter: appState.premiumActive ? appState.genderFilter : 'any',
                last_active: serverTimestamp(),
                userId: currentUserId,
            });
            console.log('User set to available.');
        } catch (e) {
            console.error('Error setting user online status:', e);
        }
    }

    /** Removes the current user's availability from Firestore and unclaims partner. */
    async function goOffline(partnerId = null) {
        if (!currentUserId || !db) return;
        try {
            // 1. Remove self from the online list
            await deleteDoc(doc(getOnlineUsersCollectionRef(), currentUserId));
            console.log('User removed from online list.');

            // 2. If we had a partner, unclaim them (optional, relies on them being self-aware)
            if (partnerId) {
                // In a real app, you would notify the partner to reset their status.
                // We simulate by trying to remove any 'claimed' status from the partner's document.
                const partnerRef = doc(getOnlineUsersCollectionRef(), partnerId);
                // Note: We use merge true in case the partner is already being claimed by someone else or has their own data.
                await updateDoc(partnerRef, {
                    status: 'available',
                    claimed_by: null,
                }).catch(err => {
                    // Ignore error if partner document no longer exists (they already went offline)
                    if (err.code !== 'not-found') console.warn("Failed to unclaim partner (they may be offline):", err);
                });
            }
        } catch (e) {
            console.error('Error setting user offline status:', e);
        }
    }

    /** Queries Firestore for an available partner based on filter. */
    async function searchForPartner() {
        console.log(`Searching for partner with filter: ${appState.genderFilter}`);
        try {
            let q = query(
                getOnlineUsersCollectionRef(),
                where('status', '==', 'available'),
                where('userId', '!=', currentUserId)
            );

            // Add gender filter if premium is active and filter is not 'any'
            if (appState.premiumActive && appState.genderFilter !== 'any') {
                // This is a simplified simulation. Real filtering would be more complex.
                // Assuming partners also store their own gender in the document.
                q = query(q, where('gender', '==', appState.genderFilter));
            }

            const querySnapshot = await getDocs(q);
            
            if (!querySnapshot.empty) {
                const partnerDoc = querySnapshot.docs[0];
                const partnerId = partnerDoc.id;

                // Attempt to claim the partner
                const partnerRef = doc(getOnlineUsersCollectionRef(), partnerId);
                await updateDoc(partnerRef, {
                    status: 'claimed',
                    claimed_by: currentUserId,
                });

                // Set my own status to 'calling'
                await updateDoc(doc(getOnlineUsersCollectionRef(), currentUserId), {
                    status: 'calling',
                    claiming: partnerId,
                });

                return partnerDoc.data(); 

            } else {
                return null;
            }
        } catch (e) {
            console.error('Error searching for partner (possible race condition):', e);
            return null;
        }
    }

    /** Main function to start the partner search and connection process. */
    async function connect() {
      if (appState.connectionStatus !== 'idle' && appState.connectionStatus !== 'not_found') return;
      
      // 1. Start local media and set self to available
      await startLocalStream();
      await goOnline();
      
      appState.connectionStatus = 'searching';
      renderApp();

      let partner = null;
      const MAX_ATTEMPTS = 5;
      const SEARCH_INTERVAL = 3000; // 3 seconds

      for (let attempts = 0; attempts < MAX_ATTEMPTS; attempts++) {
        partner = await searchForPartner();
        
        if (partner) {
            // Partner found and claimed!
            const partnerId = partner.userId;
            const partnerName = generatePartnerName(partnerId);
            
            appState.connectionStatus = 'matched';
            await startCall(partnerId, partnerName);
            return;
        }
        
        // Wait before next search attempt
        await new Promise(resolve => setTimeout(resolve, SEARCH_INTERVAL));
      }

      // If loop finishes without finding a partner
      appState.connectionStatus = 'not_found';
      await goOffline();
      
      renderApp(); 
      setTimeout(() => {
        if (appState.connectionStatus === 'not_found') {
            appState.connectionStatus = 'idle';
            renderApp();
        }
      }, 5000);
    }
    
    // --- Firestore Data Handlers (Subscription/Filter Logic) ---

    /**
     * Initializes a listener for the user's settings (subscription and filter status).
     */
    function listenForUserSettings(userId) {
      if (!db) return;
      const docRef = doc(db, USER_SETTINGS_PATH(userId));

      onSnapshot(docRef, (docSnap) => {
        if (docSnap.exists()) {
          const data = docSnap.data();
          
          const newPremium = !!data.currentPlan; 
          const newPlan = data.currentPlan || null;
          const newFilter = data.genderFilter || 'any';

          if (appState.premiumActive !== newPremium || appState.currentPlan !== newPlan || appState.genderFilter !== newFilter) {
            appState.premiumActive = newPremium;
            appState.currentPlan = newPlan;
            appState.genderFilter = newFilter;
            renderApp();
          }
        } else {
          console.log("No user settings found, creating default.");
          setDoc(docRef, {
            currentPlan: null,
            genderFilter: 'any',
            createdAt: Timestamp.now(),
            lastSeen: Timestamp.now()
          }, { merge: true }).catch(err => console.error("Error setting default settings:", err));
        }
      }, (error) => {
        console.error("Error listening to user settings:", error);
      });
    }

    /** Sets the subscription plan in Firestore. */
    async function setSubscription(planId) {
      if (!currentUserId || !db) { return false; }
      try {
        const docRef = doc(db, USER_SETTINGS_PATH(currentUserId));
        await updateDoc(docRef, {
          currentPlan: planId,
          genderFilter: 'any', 
          purchaseDate: Timestamp.now()
        });
        return true;
      } catch (e) {
        console.error("Error setting subscription:", e);
        return false;
      }
    }

    /** Updates the selected gender filter in Firestore. */
    async function updateGenderFilter(filter) {
        if (!currentUserId || !db || !appState.premiumActive) { return false; }
        try {
            const docRef = doc(db, USER_SETTINGS_PATH(currentUserId));
            await updateDoc(docRef, { genderFilter: filter });
            return true;
        } catch (e) {
            console.error("Error updating gender filter:", e);
            return false;
        }
    }

    // --- UI Event Handlers and Modals ---
    function openPremiumModal() { elements.premiumModal.style.display = 'flex'; elements.premiumModal.setAttribute('aria-hidden', 'false'); renderApp(); }
    function closePremiumModal() { elements.premiumModal.style.display = 'none'; elements.premiumModal.setAttribute('aria-hidden', 'true'); }
    function openQuestionnaire() { elements.questionModal.style.display = 'flex'; elements.questionModal.setAttribute('aria-hidden', 'false'); }
    function closeQuestionnaire() { elements.questionModal.style.display = 'none'; elements.questionModal.setAttribute('aria-hidden', 'true'); }

    function setupEventListeners() {
      // Main UI interaction listeners
      elements.connectBtn.onclick = connect;
      elements.nextPartnerBtn.onclick = nextPartner;
      elements.endCallBtn.onclick = () => endCall(true);
      elements.backBtn.onclick = backToPreviousPartner; 

      elements.premiumBtn.onclick = openPremiumModal; 
      elements.micToggle.onclick = () => toggleMedia('audio', !appState.micOn);
      elements.cameraToggle.onclick = () => toggleMedia('video', !appState.cameraOn);

      // Listener for Plan Selection
      elements.selectPlanButtons.forEach(btn => {
        btn.onclick = async () => {
          const planId = btn.dataset.planId;
          await setSubscription(planId);
        };
      });
      
      // Listener for Gender Filter Selection
      elements.filterButtons.forEach(btn => {
        btn.onclick = async () => {
            const filter = btn.dataset.filter;
            await updateGenderFilter(filter);
        };
      });
      
      // Modal Close Listeners 
      elements.closePremiumSpan.onclick = closePremiumModal;
      elements.closeQuestionSpan.onclick = closeQuestionnaire;
      elements.closeQuestionBtn.onclick = closeQuestionnaire;

      // Close modals when backdrop clicked
      [elements.questionModal, elements.premiumModal].forEach(mod => {
        mod.addEventListener('click', e => {
          if (e.target === mod) {
            if (mod.id === 'premiumModal') { closePremiumModal(); } 
            else if (mod.id === 'questionModal') { closeQuestionnaire(); }
          }
        });
      });
    }


    /** Firebase Initialization and Auth */
    async function initializeFirebase() {
      if (!firebaseConfig) { console.error("Firebase config is missing."); return; }
      
      setLogLevel('debug');
      app = initializeApp(firebaseConfig);
      db = getFirestore(app);
      auth = getAuth(app);
      
      try {
        await setPersistence(auth, browserSessionPersistence);
        if (initialAuthToken) {
          await signInWithCustomToken(auth, initialAuthToken);
        } else {
          await signInAnonymously(auth);
        }
      } catch (error) {
        console.error("Firebase Auth failed:", error);
      }

      onAuthStateChanged(auth, (user) => {
        if (user) {
          currentUserId = user.uid;
          elements.userIdDisplay.innerHTML = `User ID: ${currentUserId}`;
          listenForUserSettings(currentUserId); 
          appState.isAuthReady = true;
          openQuestionnaire(); 
        } else {
          currentUserId = null;
          elements.userIdDisplay.textContent = 'User ID: Not Signed In';
          appState.isAuthReady = false;
        }
        renderApp();
      });
    }

    // --- Run on Load ---
    window.onload = function() {
      initializeFirebase();
      setupEventListeners();
      // Ensure we go offline if the user closes the tab/window
      window.addEventListener('beforeunload', () => {
        if (currentUserId) {
            // Use sendBeacon or sync storage for final cleanup if possible, 
            // but for a simple firestore delete, relying on offline listener is often enough.
            console.log("Attempting to go offline on unload.");
            goOffline();
        }
      });
      renderApp(); 
    };

  </script>
</body>
</html>
